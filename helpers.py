from functools import reduce

import pandas as pd
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics.ranking import _binary_clf_curve
from sklearn.model_selection import StratifiedKFold
import seaborn as sns
import matplotlib.pyplot as plt
from tqdm import tqdm_notebook


def encode_dataframe(df, output_columns=None, initially_drop_columns=None, finally_drop_columns=None, drop_first=True,
                     add_non_dummified_columns=None, return_output_columns=False):
    if initially_drop_columns is not None:
        df = df.drop(initially_drop_columns, axis=1)

    df_ = pd.get_dummies(df, columns=[col for col in df.columns if col != "strat"
                                      and not pd.api.types.is_numeric_dtype(df.dtypes[col])],
                         drop_first=drop_first)

    if add_non_dummified_columns is not None:
        keep_cols = df[add_non_dummified_columns]
        df_ = pd.concat([df_, keep_cols], axis=1)

    if output_columns is not None:
        df_ = df_.reindex(columns=output_columns, fill_value=0)

    if finally_drop_columns is not None:
        df_ = df_.drop(finally_drop_columns, axis=1)

    if return_output_columns:
        return df_, df_.columns.tolist()
    else:
        return df_


def assign_y(p_ser, thr):
    return (p_ser > thr).astype(int)


def calculate_measures(trn_df, tst_df, evl_df):
    thr2dfs = {thr: {} for thr in np.arange(0.01, 0.99, 0.01)}
    for thr in thr2dfs.keys():
        train_df = trn_df.copy()
        test_df = tst_df.copy()
        eval_df = evl_df.copy()
        train_df.loc[:, "yhat"] = assign_y(train_df["p"], thr)
        test_df.loc[:, "yhat"] = assign_y(test_df["p"], thr)
        eval_df.loc[:, "yhat"] = assign_y(eval_df["p"], thr)
        thr2dfs[thr]["train_df"] = train_df
        thr2dfs[thr]["test_df"] = test_df
        thr2dfs[thr]["eval_df"] = eval_df

    return thr2dfs


def prob_operator(y_label, y_value, yhat_value, z_label, z_value, df, event, condition=None):
    def count(df, predicates, ):
        p_list = predicates.split(" ")
        df_ = df.copy()
        for pred in p_list:
            if pred == "yhat":
                df_ = df_[df_["yhat"] == yhat_value]
            elif pred == 'y':
                df_ = df_[df_[y_label] == y_value]
            elif pred == "z":
                df_ = df_[df_[z_label] == z_value]
            else:
                print(f"`{pred}` is not understood.")
                raise NotImplementedError
        return len(df_)

    if condition is not None:
        count_numerator = count(df, event + " " + condition)
        count_denum = float(count(df, condition))
        # if count_numerator == 0:
        #     print("WARN: Empty Event+Condition!")
        # elif count_denum == 0:
        #     print("WARN: Empty Condition!")
        try:
            out_ = count_numerator / count_denum
        except ZeroDivisionError:
            out_ = None
        return out_
    else:
        count_numerator = count(df, event)
        count_denum = float(len(df))
        if count_numerator == 0:
            print("WARN: Empty Event!")
        elif count_denum == 0:
            print("WARN: Empty Set!")
        return count(df, event) / float(len(df))


def metrics_dict_to_dataframe(metrics):
    return reduce(lambda df1, df2: pd.DataFrame.append(df1, df2),
                  [df.assign(model=model_name) for model_name, df in metrics.items()])
