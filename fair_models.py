from fairlearn.post_processing import ThresholdOptimizer
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.linear_model import LogisticRegression


class LogisticRegressionAsRegression:
    # This wrapper around the unconstrained estimator serves the purpose of mapping the predict
    # method to predict_proba so that we can use real values to get more accurate estimates.
    def __init__(self, logistic_regression_estimator):
        self.logistic_regression_estimator = logistic_regression_estimator

    def fit(self, X, y):
        self.logistic_regression_estimator.fit(X, y)

    def predict(self, X):
        # use predict_proba to get real values instead of 0/1, select only prob for 1
        scores = self.logistic_regression_estimator.predict_proba(X)[:, 1]
        return scores


class LogisticRegressionThresholdOptimized(BaseEstimator, ClassifierMixin):
    def __init__(self, **init_params):
        self.unconstrained_model = LogisticRegression(**init_params)
        self.fair_model_ = None
        self.sensitive_col_idx_ = None

    def fit(self, X, y, sensitive_col_idx, parity_criteria="DemographicParity"):
        self.unconstrained_model.fit(X, y)
        unconstrained_model_wrapper = LogisticRegressionAsRegression(self.unconstrained_model)
        self.fair_model_ = ThresholdOptimizer(unconstrained_model=unconstrained_model_wrapper,
                                              parity_criteria=parity_criteria)
        self.fair_model_.fit(X, y, sensitive_features=X.iloc[:, sensitive_col_idx])
        self.sensitive_col_idx_ = sensitive_col_idx
        return self.fair_model_

    def predict(self, X):
        return self.fair_model_.predict(X, sensitive_features=X.iloc[:, self.sensitive_col_idx_])

    def predict_proba(self, X):
        return self.fair_model_.predict_proba(X, sensitive_features=X.iloc[:, self.sensitive_col_idx_])

    def score(self, X, y, sample_weight=None):
        return self.fair_model_.score(X, y, sample_weight)
