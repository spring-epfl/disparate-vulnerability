import typing

import attr
import pandas as pd
import numpy as np
import scipy as sp

from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.neighbors import KNeighborsClassifier

import utils


@attr.s(auto_attribs=True)
class SubgroupSpec:
    """
    Subgroup spec in a given dataset.

    Params:
        name: Name of the subgroup
        idxs: Indices of the examples in the subgroup
    """

    name: str
    idxs: typing.Iterable


def default_attacker_model():
    knn = KNeighborsClassifier(weights="distance", p=1)
    attacker = GridSearchCV(
        knn,
        param_grid=dict(n_neighbors=[10, 20, 30, 40, 50, 60, 70, 80]),
        cv=3,
        n_jobs=-1,
    )
    return knn


def run_mia_subgroups(target_model, attacker, X, y, subgroup_specs):
    """
    Get MIA predictions on a dataset with a given attacker model.

    Args:
        target_model: Estimator-like target model
        attacker: Estimator-like attacker model

    Returns:
        dict with subgroup names as keys, :py:func:``utils.run_mia`` results as values.
    """
    results = {}
    for spec in subgroup_specs:
        subgroup_X = utils.universal_slice(X, spec.idxs)
        subgroup_y = utils.universal_slice(y, spec.idxs)
        pred_data = utils.run_mia(target_model, attacker, subgroup_X, subgroup_y)
        results[spec.name] = pred_data
    return results


def get_mia_loss_subgroups(
    ins_y_true,
    outs_y_true,
    ins_y_pred,
    outs_y_pred,
    ins_subgroup_specs,
    outs_subgroup_specs,
    mode="avg",
    bins=None,
):
    results = {}
    for spec_in, spec_out in zip(ins_subgroup_specs, outs_subgroup_specs):
        assert spec_in.name == spec_out.name
        spec_name = spec_in.name
        subgroup_ins_y_true = utils.universal_slice(ins_y_true, spec_in.idxs)
        subgroup_outs_y_true = utils.universal_slice(outs_y_true, spec_out.idxs)
        subgroup_ins_y_pred = utils.universal_slice(ins_y_pred, spec_in.idxs)
        subgroup_outs_y_pred = utils.universal_slice(outs_y_pred, spec_out.idxs)

        losses = utils.get_mia_loss_by_class(
            subgroup_ins_y_true,
            subgroup_outs_y_true,
            subgroup_ins_y_pred,
            subgroup_outs_y_pred,
            mode=mode,
            bins=bins,
        )
        for j, loss in enumerate(losses):
            num_subgroup_ins = (
                utils.universal_col_slice(subgroup_ins_y_true, j) == 1
            ).sum()
            num_subgroup_outs = (
                utils.universal_col_slice(subgroup_outs_y_true, j) == 1
            ).sum()
            num_ins = (utils.universal_col_slice(ins_y_true, j) == 1).sum()
            num_outs = (utils.universal_col_slice(outs_y_true, j) == 1).sum()
            subgroup_prop_ins = num_subgroup_ins / num_ins if num_ins > 0 else 0.
            subgroup_prop_outs = num_subgroup_outs / num_outs if num_outs > 0 else 0.
            if subgroup_prop_ins == 0 or subgroup_prop_outs == 0:
                log_ratio = 0.
            else:
                log_ratio = np.abs(
                    utils._nan_to_zero(
                        np.log(subgroup_prop_ins) - np.log(subgroup_prop_outs)
                    )
                )
            losses[:, j] += log_ratio
        results[spec_name] = losses.max(axis=0).max()

    return results


def mia_loss_subgroups_experiment(
    target_model,
    X_train,
    y_train,
    X_test,
    y_test,
    subgroup_spec_sets,
    compromised_prop=0.2,
    seed=1,
):
    """
    Run an experiment with MIA against different subgroups.
    """
    compromised_num = int(compromised_prop * len(X_train))
    assert len(X_train) >= len(X_test)
    assert len(X_test) >= compromised_num

    X_train_compromised, y_train_compromised, X_train_safe, y_train_safe = utils.subsample_data(
        X_train, y_train, size=compromised_num, seed=seed
    )
    X_test_compromised, y_test_compromised, X_test_safe, y_test_safe = utils.subsample_data(
        X_test, y_test, size=compromised_num, seed=seed
    )

    [ins_y_true, ins_y_pred], _ = utils.make_attack_part(
        target_model, X_train_compromised, y_train_compromised, label=1
    )
    [outs_y_true, outs_y_pred], _ = utils.make_attack_part(
        target_model, X_test_compromised, y_test_compromised, label=0
    )

    # Privacy loss data.
    loss_results = []
    for subgroup_spec_func in subgroup_spec_sets:
        subgroup_losses = get_mia_loss_subgroups(
            ins_y_true,
            outs_y_true,
            ins_y_pred,
            outs_y_pred,
            subgroup_spec_func(X_train_compromised),
            subgroup_spec_func(X_test_compromised),
        )

        df = pd.DataFrame()
        for subgroup, losses in subgroup_losses.items():
            df = df.append(
                pd.DataFrame({"subgroup": [subgroup], "loss": [losses]}),
                ignore_index=True,
            )
        loss_results.append(df)

    return loss_results


def mia_subgroups_experiment(
    target_model,
    X_train,
    y_train,
    X_test,
    y_test,
    subgroup_spec_sets,
    attacker=None,
    compromised_prop=0.2,
    test_size=0.3,
    seed=1,
):
    """
    Run an experiment with MIA against different subgroups.
    """
    compromised_num = int(compromised_prop * len(X_train))
    assert len(X_train) >= len(X_test)
    assert len(X_test) >= compromised_num

    X_train_compromised, y_train_compromised, X_train_safe, y_train_safe = utils.subsample_data(
        X_train, y_train, size=compromised_num, seed=seed
    )
    X_test_compromised, y_test_compromised, X_test_safe, y_test_safe = utils.subsample_data(
        X_test, y_test, size=compromised_num, seed=seed
    )

    attacker_X, attacker_y = utils.make_attack_data(
        target_model,
        X_train_compromised,
        X_test_compromised,
        y_train_compromised,
        y_test_compromised,
    )

    attacker_X = utils.attack_data_to_matrix(attacker_X)
    attacker_X_train, attacker_X_test, attacker_y_train, attacker_y_test = train_test_split(
        attacker_X, attacker_y, test_size=test_size, random_state=seed
    )
    attacker_X_train.shape, attacker_X_test.shape

    if attacker is None:
        attacker = default_attacker_model()
    attacker.fit(attacker_X_train, attacker_y_train)

    X_train_safe_subsample, y_train_safe_subsample, _, _ = utils.subsample_data(
        X_train_safe, y_train_safe, len(X_test_safe)
    )

    # TP rates.
    tp_results = []
    # FP rates.
    fp_results = []
    for subgroup_spec_func in subgroup_spec_sets:
        train_specs = subgroup_spec_func(X_train_safe_subsample)
        test_specs = subgroup_spec_func(X_test_safe)
        tp_data = run_mia_subgroups(
            target_model,
            attacker,
            X_train_safe_subsample,
            y_train_safe_subsample,
            train_specs,
        )
        tp_results.append(tp_data)

        fp_data = run_mia_subgroups(
            target_model, attacker, X_test_safe, y_test_safe, test_specs
        )
        fp_results.append(fp_data)

    score = (
            attacker.score(attacker_X_test, attacker_y_test),
            attacker.score(attacker_X_train, attacker_y_train)
    )
    return tp_results, fp_results, score


def experiment_results_to_dataframes(results):
    """Convert a subgroup attack results into a dataframe."""
    dfs = []

    for subgroup_name, subgroup_data in results.items():
        shape = subgroup_data["target_y_proba"].shape
        size = shape[0]
        if len(shape) == 1:
            num_classes = 2
            df = pd.DataFrame(
                {
                    "subgroup": [subgroup_name] * size,
                    "attack_pred": subgroup_data["attack_pred"],
                    "target_y_true": subgroup_data["target_y_true"],
                    "target_y_pred": subgroup_data["target_y_pred"],
                    "target_y_proba": subgroup_data["target_y_proba"],
                }
            )
        else:
            num_classes = shape[1]
            df = pd.DataFrame(
                {
                    "subgroup": [subgroup_name] * size,
                    "attack_pred": subgroup_data["attack_pred"],
                    "target_y_true": str(subgroup_data["target_y_true"]),
                    "target_y_pred": str(subgroup_data["target_y_pred"]),
                    "target_y_proba": str(subgroup_data["target_y_proba"]),
                }
            )

        dfs.append(df)

    return pd.concat(dfs, ignore_index=True)
