from scipy.stats import entropy

import numpy as np

import utils


def _get_histograms(subgroup_ins_y_pred, subgroup_outs_y_pred, class_index, bins):
    # Choose the smallest binning that works for both in and out distributions.
    j = class_index
    ins_min, ins_max = (
        subgroup_ins_y_pred[:, j].min(),
        subgroup_ins_y_pred[:, j].max(),
    )
    outs_min, outs_max = (
        subgroup_outs_y_pred[:, j].min(),
        subgroup_outs_y_pred[:, j].max(),
    )
    bin_range = (min(ins_min, outs_min), max(ins_max, outs_max))
    bin_edges = np.histogram_bin_edges(
        np.concatenate([subgroup_ins_y_pred[:, j], subgroup_outs_y_pred[:, j]]),
        bins=bins, range=bin_range
    )

    # Record the histograms.
    ins_probs, _ = np.histogram(
        subgroup_ins_y_pred, bins=bin_edges, density=True
    )
    outs_probs, _ = np.histogram(
        subgroup_outs_y_pred, bins=bin_edges, density=True
    )
    dx = np.diff(bin_edges)
    return ins_probs * dx, outs_probs * dx


def get_mia_loss_subgroups(
    ins_y_true,
    outs_y_true,
    ins_y_pred,
    outs_y_pred,
    ins_subgroup_specs,
    outs_subgroup_specs,
    use_subgroup_overfitting=True,
    use_sampling_bias=True,
    bins="auto",
    mode="tv",
):
    results = {}
    for spec_in, spec_out in zip(ins_subgroup_specs, outs_subgroup_specs):
        assert spec_in.name == spec_out.name
        spec_name = spec_in.name
        subgroup_ins_y_true = utils.universal_slice(ins_y_true, spec_in.idxs)
        subgroup_outs_y_true = utils.universal_slice(outs_y_true, spec_out.idxs)
        subgroup_ins_y_pred = utils.universal_slice(ins_y_pred, spec_in.idxs)
        subgroup_outs_y_pred = utils.universal_slice(outs_y_pred, spec_out.idxs)

        num_classes = utils.get_num_classes(ins_y_pred)
        ins_hists_by_class = [1. for j in range(num_classes)]
        outs_hists_by_class = [1. for j in range(num_classes)]

        # Get the the in/out prediction histograms on the same binning grid.
        if use_subgroup_overfitting:
            for j in range(num_classes):
                ins_hists_by_class[j], outs_hists_by_class[j] = _get_histograms(
                        subgroup_ins_y_pred, subgroup_outs_y_pred, j, bins=bins)

        # Compute the subgroup sampling biases.
        if use_sampling_bias and mode != "tv":
            num_subgroup_ins = len(spec_in.idxs)
            num_subgroup_outs = len(spec_out.idxs)
            num_ins = len(ins_y_true)
            num_outs = len(outs_y_true)
            subgroup_prop_ins = num_subgroup_ins / num_ins if num_ins > 0 else 0.
            subgroup_prop_outs = num_subgroup_outs / num_outs if num_outs > 0 else 0.
        else:
            subgroup_prop_ins = 1.
            subgroup_prop_outs = 1.

        val_by_class = []
        for j in range(num_classes):
            non_zeros = (ins_hists_by_class[j] != 0.) & (outs_hists_by_class[j] != 0.)
            if mode == "inf":
                val = max(np.max(
                    np.log(ins_hists_by_class[j][non_zeros]) + np.log(subgroup_prop_ins) -
                    np.log(outs_hists_by_class[j][non_zeros]) - np.log(subgroup_prop_outs)
                ),
                np.max(
                    -np.log(ins_hists_by_class[j][non_zeros]) - np.log(subgroup_prop_ins) +
                    np.log(outs_hists_by_class[j][non_zeros]) + np.log(subgroup_prop_outs)
                ))
            elif mode == "kl":
                val = entropy(
                    ins_hists_by_class[j][non_zeros] * subgroup_prop_ins,
                    outs_hists_by_class[j][non_zeros] * subgroup_prop_outs
                ) + \
                entropy(
                    ins_hists_by_class[j][non_zeros] * subgroup_prop_ins,
                    outs_hists_by_class[j][non_zeros] * subgroup_prop_outs
                )
            elif mode == "tv":
                in_term = ins_hists_by_class[j]
                out_term = outs_hists_by_class[j]
                val = np.sum(np.abs(in_term - out_term))
            else:
                raise ValueError("Unknown mode: %s" % mode)

            val_by_class.append(val)

        results[spec_name] = max(val_by_class)

    return results

