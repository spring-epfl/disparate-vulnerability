import itertools
import numpy as np
import pandas as pd


class ProbabilityEstimator:
    """
    Probability operator builder.

    >>> X = pd.DataFrame({"a": [1, 1, 2], "b": [3, 6, 3]})
    >>> prob_est = ProbabilityEstimator()
    >>> prob_est.of("a", 1).given("b", 4).fit(X)
    0.0
    >>> prob_est.of("a", 1).given("b", 3).fit(X)
    0.5
    >>> prob_est.of("a", 1).given("b", 6).fit(X)
    1.0
    """

    def __init__(self, of=None, given=None):
        self.lhs_exprs = of or {}
        self.rhs_exprs = given or {}

    def clear(self):
        self.lhs_exprs = {}
        self.rhs_exprs = {}

    @staticmethod
    def _build_query(**kwargs):
        queries = [f"`{k}` == {repr(v)}" for (k, v) in kwargs.items()]
        return " and ".join(queries)

    def __repr__(self):
        return f"ProbabilityEstimator(of={self.lhs_exprs}, given={self.rhs_exprs})"

    def of(self, label, value):
        self.lhs_exprs[label] = value
        return self

    def given(self, label, value):
        self.rhs_exprs[label] = value
        return self

    def fit(self, X):
        count_df = X.query(self._build_query(**self.lhs_exprs, **self.rhs_exprs))
        count = len(count_df)
        if self.rhs_exprs:
            norm_df = X.query(self._build_query(**self.rhs_exprs))
            norm = len(norm_df)
        else:
            norm = len(X)
        self.clear()

        if norm == 0.0:
            return 0.
        return count / norm


def regular_vuln(learn_df, eval_df,
                 y_label, p_label, z_label,
                 y_range=None, p_range=None, z=None,
                 full_set_eval=True):
    if y_range is None:
        y_range = [0, 1]
    if p_range is None:
        p_range = [0, 1]

    obs_space = itertools.product(p_range, y_range)
    if full_set_eval:
        combined_df = learn_df.append(eval_df)

    res = 0.0
    # print(f">> REGULAR. z={repr(z)}")
    for (yhat, y) in obs_space:
        # max_m Pr[m | p, y]
        vuln = ProbabilityEstimator().of("m", 1) \
                    .given(p_label, yhat) \
                    .given(y_label, y) \
                    .fit(learn_df if not full_set_eval else combined_df)
        vuln = max(vuln, 1 - vuln)

        # Pr[p, y]
        obs_prob = ProbabilityEstimator() \
                    .of(p_label, yhat) \
                    .of(y_label, y) \

        if z is not None:
            # or Pr[p, y | z]
            obs_prob = obs_prob.given(z_label, z)

        p = obs_prob.fit(eval_df if not full_set_eval else combined_df)

        # print(f"{yhat} {y}: {vuln} {p}")
        res += vuln * p

    return res


def regular_vuln_empirical_avg(learn_df, eval_df,
                  y_label, p_label, z_label,
                  y_range=None, p_range=None, z=None):
    if y_range is None:
        y_range = [0, 1]
    if p_range is None:
        p_range = [0, 1]

    obs_space = itertools.product(p_range, y_range)

    # Bayes adversary.
    class Adv:
        def __init__(self):
            pass

        def fit(self, learn_df):
            """Use frequentist estimation to estimate the Bayes adversary."""
            self.decisions_ = {}
            for (yhat, y) in obs_space:
                # max_m Pr[m | p, y]
                vuln0 = ProbabilityEstimator().of("m", 0) \
                            .given(p_label, yhat) \
                            .given(y_label, y) \
                            .fit(learn_df)
                vuln1 = ProbabilityEstimator().of("m", 1) \
                            .given(p_label, yhat) \
                            .given(y_label, y) \
                            .fit(learn_df)
                # self.decisions_[(yhat, y)] = 1. if vuln >= 0.5 else 0.
                self.decisions_[(yhat, y)] = np.argmax([vuln0, vuln1])

        def predict(self, x):
            """Predict in/out on an observation."""
            return self.decisions_[x[p_label], x[y_label]]

    # Estimate the Bayes adversary.
    adv = Adv()
    adv.fit(learn_df)

    # Compute the vulnerability as accuracy of the adversary on eval_df.
    if z is not None:
        eval_df = eval_df.query(f"`{z_label}` == {repr(z)}")

    res = (eval_df.apply(adv.predict, axis=1) == eval_df.m).mean()
    return res


def discriminating_vuln(learn_df, eval_df,
                        y_label, p_label, z_label, z_values,
                        y_range=None, p_range=None, z=None,
                        full_set_eval=False):
    if y_range is None:
        y_range = [0, 1]
    if p_range is None:
        p_range = [0, 1]

    res = 0.0
    if z is not None:
        z_values = [z]

    if full_set_eval:
        combined_df = learn_df.append(eval_df)

    obs_space = itertools.product(p_range, y_range, z_values)

    # print(f">> DISCRIM. z={repr(z)}")
    for (yhat, y, z_prime) in obs_space:
        # max_m Pr[m | p, y, z']
        vuln = ProbabilityEstimator().of("m", 1) \
                    .given(p_label, yhat) \
                    .given(y_label, y) \
                    .given(z_label, z_prime) \
                    .fit(learn_df if not full_set_eval else combined_df)
                    # .fit(learn_df.append(eval_df))
        vuln = max(vuln, 1 - vuln)

        obs_prob = ProbabilityEstimator() \
                    .of(p_label, yhat) \
                    .of(y_label, y) \

        if z is None:
            # Pr[p, y, z']
            obs_prob = obs_prob.of(z_label, z_prime)
        else:
            # Pr[p, y | z]
            obs_prob = obs_prob.given(z_label, z)

        # p = obs_prob.fit(learn_df.append(eval_df))
        p = obs_prob.fit(eval_df if not full_set_eval else combined_df)
        # print(f"{yhat} {y} {z_prime}: {vuln} {p}")
        res += vuln * p

    return res


def discriminating_vuln_empirical_average(learn_df, eval_df,
                  y_label, p_label, z_label, z_values,
                  y_range=None, p_range=None, z=None):
    if y_range is None:
        y_range = [0, 1]
    if p_range is None:
        p_range = [0, 1]

    obs_space = itertools.product(p_range, y_range, z_values)

    class DAdv:
        def __init__(self):
            pass

        def fit(self, learn_df):
            self.decisions_ = {}
            for (yhat, y, z_prime) in obs_space:
                vuln0 = ProbabilityEstimator().of("m", 0) \
                            .given(p_label, yhat) \
                            .given(y_label, y) \
                            .given(z_label, z_prime) \
                            .fit(learn_df)
                vuln1 = ProbabilityEstimator().of("m", 1) \
                            .given(p_label, yhat) \
                            .given(y_label, y) \
                            .given(z_label, z_prime) \
                            .fit(learn_df)
                # self.decisions_[(yhat, y, z_prime)] = 1. if vuln >= 0.5 else 0.
                self.decisions_[(yhat, y, z_prime)] = np.argmax([vuln0, vuln1])

        def predict(self, x):
            return self.decisions_[x[p_label], x[y_label], x[z_label]]

    adv = DAdv()
    adv.fit(learn_df)

    if z is not None:
        eval_df = eval_df.query(f"`{z_label}` == {repr(z)}")
    res = (eval_df.apply(adv.predict, axis=1) == eval_df.m).mean()
    return res


def estimate_vulnerability(train_learn_df, train_eval_df, test_learn_df, test_eval_df,
                           attacker, p_label, y_label, z_label, z_values, z_value=None,
                           y_range=None, p_range=None,
                           full_set_eval=False):
    if y_range is None:
        y_range = [0, 1]
    if p_range is None:
        p_range = [0, 1]

    learn_df = train_learn_df.assign(m=1).append(test_learn_df.assign(m=0))
    eval_df = train_eval_df.assign(m=1).append(test_eval_df.assign(m=0))

    if attacker == "regular":
        vuln = regular_vuln(learn_df, eval_df, y_label=y_label, p_label=p_label,
                z_label=z_label, y_range=y_range, p_range=p_range, z=z_value,
                full_set_eval=full_set_eval)

    elif attacker == "discriminating":
        vuln = _discriminating_vuln(learn_df, eval_df, y_label=y_label, yhat_label=yhat_label,
                z_label=z_label, z_values=z_values, y_range=(0, 1), yhat_range=(0, 1), z=z_value)
    else:
        raise NotImplementedError

    return vuln

