import tqdm
import numpy as np
import pandas as pd

from scipy.special import softmax

from mia import utils

from dpml_benchmark.algorithms import approximate_minima_perturbation as amp
from dpml_benchmark.algorithms import psgd


class BaseDPMLEstimator:
    def __init__(self, num_classes, epsilon=1, fit_args=None, verbose=False):
        self.num_classes = num_classes
        self.epsilon = epsilon
        self.verbose = verbose
        self.fit_args = fit_args or {}
        self.classes_ = np.arange(num_classes)

    def build_binary_ys(self, vec_ys):
        binary_ys = []
        for i in range(self.num_classes):
            binary_ys.append(np.array([1 if y == i else -1 for y in vec_ys]))
        return binary_ys

    def fit(self, X, y):
        X = utils.ensure_numpy(X)
        y = utils.ensure_numpy(y)
        amp_train_ys = self.build_binary_ys(y)

        results_set = []
        if self.verbose:
            it = tqdm.tqdm_notebook(amp_train_ys, leave=False)
        else:
            it = y

        self.training_results_ = []
        delta = 1 / len(X) ** 2
        for i, binary_train_y in enumerate(it):
            self.training_results_.append(
                self.algo.run_classification(
                    X,
                    binary_train_y,
                    self.epsilon / self.num_classes,
                    delta,
                    **self.fit_args
                )
            )

    def decision_function(self, X):
        X = utils.ensure_numpy(X)
        n = X.shape[0]
        y_hat = np.zeros((n, self.num_classes))
        for i in range(n):
            for j, training_result in enumerate(self.training_results_):
                if isinstance(training_result, tuple):
                    theta, _ = training_result
                else:
                    theta = training_result
                y_hat[i, j] = theta @ X[i]
        return y_hat

    def predict_proba(self, X):
        X = utils.ensure_numpy(X)
        return softmax(self.decision_function(X), axis=1)

    def predict(self, X):
        return utils.get_classes_from_confidence(self.predict_proba(X))

    def score(self, X, y):
        X = utils.ensure_numpy(X)
        y = utils.ensure_numpy(y)
        return (self.predict(X) == y).mean()


class AmpLR(BaseDPMLEstimator):
    algo = amp.ApproximateMinimaPerturbationLR


class PsgdLR(BaseDPMLEstimator):
    algo = psgd.PrivateConvexPSGDLR
